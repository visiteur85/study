conventionalcommits.org - здесь пишут как правильно писать коммит

mkdir название проекта - создание папки
git init - инициализация папки для работы с гитом
## add делаем файл отслеживаемым
git add - подготовить файл для гита
	. - добавить все файлы текущей папки
	*.css - добавить все с расширениеи
	someDir/*css добавить все фацлы в папке somedir c расширением css
	somedir/ добавить все файлы в папке sd
	"*.css добавить все файлы в проекте с раширением css
##
git status - узнать текущий статус файла (бвает 4 состояния ignored, new/untracked - гит еще не начал следить за файлами
, staged - добавлены в add, commited - добавлены комит
git commit -m "название изменения"
git log  - посмотреть историю комитов
git log -n (число) вывести историю комитов в количестве таком то

## diff
git diff разница между текущим состоянием и последним комитом
	--staged показывает разницу между текущим отслеживаемым состоянием и последним снимком
	commit_id(просто вставляем номер комита) разницаа между тек состоянием и указанным снимком
##

## clone загрузка удалённого репозитория в локальное хранилище
git clone адрес удаленного репозитория


## reset (удалить файлы из индекса, а add добавляет)
git reset HEAD^ - смещение на один коммит назад
git rest ~2  -на количество коммитов 
или
git reset HEAD^^ - ^^- количество коммитов
режим откатов
-	 --soft самый мягкий режим
-	--mixed (дефолтный режим если не указать)комиты остаются , но переводятся в неотслжеиваюмую зону
-	--hard (удаляет коммиты)

общая формула
git reset [--soft, --mixed, --hard] [commit - опционально например reset --hard Head^^ или git reset "хэш"  ]

## checkout
git checkout <hash commit>   вернутся к сомиту , но все добавления будут удалены при переходе на другой коммит
git checkout master(мастер - это название текущи ветки) - переход обратно к актуальному комиту
git checkout hash -- fileName1 fileNmae2 - вернет эти файла к версии комита, который мы указали в хэш(работает только для от
слеживаемых изменений)
git checkout --. - вернет все файлы в репозитории к состоянию последнего комита(или можно указать конкретный файл)

##

## commit
git commit -m "text commits"
git commit --amend -m "text_commit" - добавляет в коммит новые изменения


## выход из VIM - :wq

## clean
git clean 
-    -n  -покажет какие файлы будут удалены
-    -f -- удалят untracked files

## remote
git remote работа с удаленными репозиториями
-	-v  смотреть все репозитории
-	add  НАЗВАНИЕ_РЕПОЗИТОРИЯ(origin) аДрЕс_РеПоЗиТоРиЯ добавить новый улаоеееый репо
, который находится по указанному адресу. При этом на нашем компьютере к удаленному репо мы будет обращаться оп его названию 
-	remove НАЗВАНИЕ_РЕПОЗИТОРИЯ удалить
 - remote show (название репо) - увидеть все ветки в проекте   (если есть up to date - значит наши лок не синхронизированы с уд
аленными

## git push 
git push НАЗВАНИЕ_УДАЛЁННОГО_РЕПОЗИТОРИЯ   ВЕТКА команда для отправки локального репозитория на удленный
 ПРИМЕР GIT PUSH ORIGIN MASTER  - так отправляется на удаленный репозиторий и именем origin нашу ветку master
git push --delete origin (название ветки) - удаление ветки с репо на гите

## git pull - получение обновлений с репозитория на локальное хранилище своей машины
git pull origin master как работает: 1. скачивает удаленную ветку с удаленного репо(обновляет ветку орижин масте)
				2. сливает удаленную втку с локальной веткой(производит атуалиацию вашей локальной
				ветки)
				тоже самое для лбой др ветки. (git pull origin название ветки)
по сути git pull состоит из двух команд git fetch - скачивает удалённые ветки с репо, но не производит актуализацию ваших ло
кальный веток (не делает слияния удаленной ветки с локальной)
и вторая команда слияние git merge origim


##git init - локально инициализировать git
git remote add origin <link to git repo>  привязать удаленный repo 


## cherry-pick
выбрать и добавить в текoую ветку коммиты из другой
git cherry-pick hash_commit hash_commit
### доп. аргументы
-	--edit - изменить имя коммита
-	--no-commit   -без названия коммита
-	-x - добавит хэш оригинального коммита
-	--signoff - указывает имя пользователя кто совершил cherry-pick

##Настройка SSH - сетевой протокол , позволяющий производить удалённое управление операционное системой. создается приватный и 
пуюличгый ключ. публичный ключ копируется на сервер. его копируем на гитхабе. приватный только у нас
1. проверить существование действующих ключей на компе ls -al ~/.ssh
2. подключить email для генерации ssh-keygen -t rsa -b 4096 -C "email"
3. запустить SSH agent - eval "$(ssh-agent -s)"
4. добавить ключи в сгенерированный ssh agent - ssh-add -K ~/.ssh/id_rsa (была проблема Итак, вместо того, чтобы писать
$ ssh-add -K ~/.ssh/private_key
Напишите это:
$ ssh-add ~/.ssh/id_rsa 
Замените private_key своим ключом, например $ ssh-add ~ / .ssh / id_rsa
5.копируем публичный ключ. clip < ~/.ssh/id_rsa.pub (для мака pbcopy < ~/.ssh/id_rsa.pub)
6. далее ввести этот ключ в гитхабе (настройки, ssh and gpg  - new ssh
7. сменить ссылку на удаленный репозиторий в гит хабе: 
git remote -v смотреть список текущих ремоутов 
git remote remove origin
git remote add origin (ссылка на ssh уже, а не https)

##git branch())
git checkout -b new-branch - создание новой ветки
git branch - увидеть название локальной ветки, на которой мы находимся(на какой ветке находится HEAD)
git branch -r   - увидеть все удаленный репо (локальные ветки изменяются мнойй, удаленные др людьми), когда мы скачиваем pull, мы до
бавляем ветку с удаленного репо
git branch -d название ветки - удаление веткис этим названием(но она не даст удвалить ветки, если мы не слили с нее измен
енине, поэтому нужна команда с большой буквой D)
git branch название ветки  - создание ветки
git branch checkout називание_ветки - переключение между ветками
git merge название ветки - сливает вторую ветку в мастер(сначала переходим в ветку мастер с помощью команды checkout)
 !!!конфлиткты слияний что делать, если два пользователя изменяли одно и то же место в одном файле??? будет merge конфликт. 
как его решить. нужно вручную решить, откуда мы забираем изменения. в этом случае прямо в терминале будет написано, что есть 
конфликт, если выбрать гит статус, что покажут файл, в котором конфликт. далее, открыть этот файл не через терминал и мы у
вдиим область, в которой проблема. далее прямо в фалйе редактируем. замтем мы делаем гит адд. далее гит коммит (просто git commit)
нас опять переводит в редактор v, далее выходим из редактора w?, нажимая :wk.

## rebase есть два вида слияний. fast forvard - т.е. когда в основной ветке, от котороый мы отпочковались, не было
никаких изменений и когда мы сливаем новую ветку в основную, мы продолжаем работать так, как будто новой ветки и не было
т.е. не образуется мерж комит## rebase. но бывают ситуации, что когда мы отпочковались, и работали в своей ветке, в основной
произошли какие то комиты. тогда гит не может слить с помощью фаст форвард, он сливает с помощью нового комита слияяния, т.
е. нового  мерж комита . мноиге ситают, что эти комиты слияния просто мусор и для этого была придумана команда rebase (
альтернатива merge). но команда не создает комитов слияния. итак, отличие rebase от merge:
 - обе команды делают дно и то же - сливают ветки.
 - команда мерж может создавать меж комит пр слиянии (в случае не фаст форвард), команда рибэйз не создает мерж коммит
 - команда мерж безопасне
 - плюс мерж - достоверная полная история комитов
 - плюс рибэйз лаконичная оинейная история без лишних комитов
 - если в ветке долго велась работа и произошло много изменений, лучше использовать merge
  - если ветка был недолгая и прозошло мало изменений, можно рибэйз
 - используйте мерж, если вас не просили рибэйз

